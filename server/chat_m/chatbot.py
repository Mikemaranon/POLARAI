import os
import json
import requests
from datetime import datetime
from chat import Chat

DATA_PATH = "server/data/chat-history/"  # Ubicación de los historiales de chat

class Chatbot:
    def __init__(self, user, name, api_key, endpoint):
        
        # Initializes a Chatbot object with its name, API key, endpoint, and owning user.
        
        # :param user: Name of the user who owns this chatbot.
        # :param name: Name of the chatbot (e.g., "google-gemini", "azure-gpt-4o-mini").
        # :param api_key: API key for authentication.
        # :param endpoint: URL of the AI model endpoint.
        
        self.user = user
        self.name = name
        self.api_key = api_key
        self.endpoint = endpoint
        self.chat_history_path = os.path.join(DATA_PATH, user, f"{name}.json")
        os.makedirs(os.path.dirname(self.chat_history_path), exist_ok=True)
        
        self.chats = self.load_chat_history()
        
    def load_chat_history(self):
        
        # Loads the chat history from the JSON file.
        
        # :return: List of Chat objects with the data from the JSON file.
        
        chat_list = []
        
        if os.path.exists(self.chat_history_path):
            with open(self.chat_history_path, "r") as file:
                chats_file = json.load(file)      
                
        for chat in chats_file:
            chat_list.append(Chat (
                id = chat["id"],
                timestamp = chat["timestamp"],
                messages = chat["messages"]
            ))
        
        return []
        
    def send_message(self, message):
        
        # Sends a message to the chatbot and saves the conversation in the history.
        #
        # :param message: Input text for the model.
        # :return: Response generated by the model.
        
        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}
        payload = {"input": message}

        try:
            response = requests.post(self.endpoint, headers=headers, json=payload)
            response.raise_for_status()
            bot_response = response.json().get("response", "Error: No se recibió respuesta.")
        except requests.exceptions.RequestException as e:
            bot_response = f"Error: {str(e)}"

        # Guardar mensaje en historial
        self.update_chat(bot_response)
        return bot_response

    def new_chat(self, user_message, bot_message):
        
        # Saves a new chat.

        # :param user_message: User's message.
        # :param bot_message: Chatbot's response.
        
        chat_id = self.generate_chat_id()
        timestamp = datetime.now().isoformat()

        chat_entry = {
            "id": chat_id,
            "timestamp": timestamp,
            "messages": [
                {"sender": "user", "content": user_message},
                {"sender": "bot", "content": bot_message}
            ]
        }

        history = self.load_chat_history()
        history.append(chat_entry)

        with open(self.chat_history_path, "w") as file:
            json.dump(history, file, indent=4)

    def update_chat(self, chat_id, bot_message):
        
        # Updates an existing chat with the chatbot's response.

        # :param chat_id: Unique ID of the chat.
        # :param bot_message: Chatbot's response.
        
        history = self.load_chat_history()

        for chat in history:
            if chat["id"] == chat_id:
                chat["messages"].append({"sender": "bot", "content": bot_message})
                break

        with open(self.chat_history_path, "w") as file:
            json.dump(history, file, indent=4)

    @staticmethod
    def generate_chat_id():
        # Genera un ID único basado en la fecha y hora.
        return datetime.now().strftime("Chat-%Y%m%d%H%M%S")

    def __repr__(self):
        return f"Chatbot(user={self.user}, name={self.name}, endpoint={self.endpoint})"
